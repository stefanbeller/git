This directory provides examples of Coccinelle (http://coccinelle.lip6.fr/)
semantic patches that might be useful to developers.

There are two types of semantic patches:

 * Using the semantic transformation to check for bad patterns in the code;
   This is what the original target 'make coccicheck' is designed to do and
   it is expected that any resulting patch indicates a regression.
   The patches resulting from 'make coccicheck' are small and infrequent,
   so once they are found, they can be sent to the mailing list as per usual.

   Example for introducing new patterns:
   67947c34ae (convert "hashcmp() != 0" to "!hasheq()", 2018-08-28)
   b84c783882 (fsck: s/++i > 1/i++/, 2018-10-24)

   Example of fixes using this approach:
   248f66ed8e (run-command: use strbuf_addstr() for adding a string to a strbuf, 2018-03-25)
   f919ffebed (Use MOVE_ARRAY, 2018-01-22)

   Behavior of these
   0860a7641b (travis-ci: fail if Coccinelle static analysis found something to transform, 2018-07-23)

 * Using semantic transformations in large scale refactorings throughout
   the code base.

   When applying the semantic patch into a real patch, sending it to the
   mailing list in the usual way, such a patch would be expected to have a
   lot of textual and semantic conflicts as such large scale refactorings
   change function signatures that are used widely in the code base.
   A textual conflict would arise if surrounding code near any call of such
   function changes. A semantic conflict arises when other patch series in
   flight introduce calls to such functions.

   So to aid these large scale refactorings, semantic patches can be used,
   using the process as follows:

   1) Figure out what kind of large scale refactoring we need
      -> This is usually done by another unrelated series.
   2) Create the sematic patch needed for the large scale refactoring
      and store it in contrib/coccinelle/*.pending.cocci
      -> The suffix containing 'pending' is important to differentiate
      this case from the other use case of checking for bad patterns.
   3) Apply the semantic patch only partially, where needed for the patch series
      that motivates the large scale refactoring and then build that series
      on top of it.
      By applying the semantic patch only partially where needed, the series
      is less likely to conflict with other series in flight.
      To make it possible to apply the semantic patch partially, there needs
      to be mechanism for backwards compatibility to keep those places working
      where the semantic patch is not applied. This can be done via a
      #define

   4) Send the series as usual.

   Later steps (not necessarily by the original author) are to apply the
   semantic patch in a way











